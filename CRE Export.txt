// ==UserScript==
// @name         Unprocessed Keywords- Export CSV
// @namespace    http://tampermonkey.net/
// @version      2.7
// @description  Export unprocessed keywords with on-screen progress modal.
// @author       Tushar Gautam- @tuxgauta
// @match        https://content-risk-engine-iad.iad.proxy.amazon.com/keyword-management/unprocessed-keywords*
// @grant        GM_xmlhttpRequest
// @grant        GM_download
// @run-at       document-idle
// ==/UserScript==

(function () {
  "use strict";
  console.info("[CRE Export v2.7] loaded");

  const API_ENDPOINT = "/api/keyword-management/list-unprocessed-keywords";
  const PAGE_SIZE = 100;
  const EXPORT_BTN_TEXT = "EXPORT CSV";

  function formatEpochMsToUTC(ms) {
    if (!ms) return "";
    const d = new Date(Number(ms));
    if (Number.isNaN(d.getTime())) return "";
    const pad = n => String(n).padStart(2, "0");
    const Y = d.getUTCFullYear();
    const M = pad(d.getUTCMonth() + 1);
    const D = pad(d.getUTCDate());
    const h = pad(d.getUTCHours());
    const m = pad(d.getUTCMinutes());
    const s = pad(d.getUTCSeconds());
    return `${Y}-${M}-${D} ${h}:${m}:${s}`;
  }

  function readReactSelectValues(dropdownId) {
    try {
      if (!dropdownId) return [];
      const container = document.getElementById(dropdownId);
      if (!container) return [];
      const chips = Array.from(container.querySelectorAll(".css-1rhbuit-multiValue, .css-1g6gooi .multi-value, .multi-value"));
      if (chips && chips.length) return chips.map(c => c.textContent.trim()).filter(Boolean);
      const single = container.querySelector(".css-1uccc91-singleValue");
      if (single && single.textContent && single.textContent.trim()) return [single.textContent.trim()];
      const placeholder = container.querySelector(".css-1wa3eu0-placeholder");
      if (placeholder && placeholder.textContent && placeholder.textContent.trim()) {
        const txt = placeholder.textContent.trim();
        return /select/i.test(txt) ? [] : [txt];
      }
      const t = (container.innerText || "").trim();
      if (!t) return [];
      return t.split(/\r?\n|,/).map(s => s.trim()).filter(Boolean);
    } catch (e) { console.warn("readReactSelectValues error", e); return []; }
  }

  function buildTemplateFromReactSelects() {
    const adPrograms = readReactSelectValues("ap-dropdown");
    const marketplaces = readReactSelectValues("mp-dropdown");
    const kwSource = readReactSelectValues("kwsource-dropdown");
    const policies = readReactSelectValues("policy-dropdown");
    const states = readReactSelectValues("kwstate-dropdown") || [];

    const processes = adPrograms.length ? adPrograms.map(s => s.toUpperCase()) : [];
    const mps = marketplaces.length ? marketplaces.map(s => s.toUpperCase()) : [];
    const kws = kwSource.length ? kwSource.map(s => s.toUpperCase()) : [];
    const labels = policies.length ? policies.map(s => s.toUpperCase()) : [];

    const t = {
      author: "",
      keywordSearchCriteria: {
        assignedTos: [],
        keywordSources: kws,
        labels: labels,
        marketplaces: mps,
        processes: processes,
        states: states
      },
      pagination: { size: PAGE_SIZE, startIndex: 0 }
    };

    return { template: t, detected: { processes, marketplaces: mps, kwSource: kws, policies: labels } };
  }

  function normalizeItemsArray(json) {
    if (!json) return [];
    if (Array.isArray(json.keywordRecords)) return json.keywordRecords;
    if (Array.isArray(json.items)) return json.items;
    if (Array.isArray(json.results)) return json.results;
    const keys = Object.keys(json || {});
    if (keys.length && keys.every(k => /^\d+$/.test(k))) {
      return keys.sort((a,b)=>Number(a)-Number(b)).map(k=>json[k]);
    }
    for (const k of keys) if (Array.isArray(json[k])) return json[k];
    return [];
  }

  function mapItemToCsvRow(item) {
    const keywordName = (item.keywordDetails && item.keywordDetails.keywordName) || item.keywordName || item.keyword || "";
    const attributeFlag = (item.keywordDetails && item.keywordDetails.attributeFlagged) || item.attributeFlagged || "";
    const ingestionDate = item.creationTime ? formatEpochMsToUTC(item.creationTime) : (item.keywordIngestionDate || "");
    return [
      item.process || item.adProgram || "",
      item.marketplace || "",
      keywordName,
      item.label || item.policy || "",
      item.keywordSource || "",
      attributeFlag,
      item.ingestedUserName || item.keywordIngestedBy || "",
      item.referenceSim || item.reference || "",
      ingestionDate,
      item.state || "",
      item.assignedTo || item.assignedUser || ""
    ];
  }

  function triggerCsvDownload(rows) {
    const header = ["AD PROGRAM","MARKETPLACE","KEYWORD","POLICY","KEYWORD SOURCE","ATTRIBUTE FLAGGED","KEYWORD INGESTED BY","REFERENCE SIM","KEYWORD INGESTION DATE/TIME (UTC)","STATE","ASSIGNED USER"];
    const lines = [header.join(",")];
    for (const r of rows) {
      const escaped = r.map(v => {
        if (v === null || v === undefined) return "";
        const s = String(v);
        if (/["\n\r,]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
        return s;
      });
      lines.push(escaped.join(","));
    }
    const csv = lines.join("\r\n");
    const filename = `cre-unprocessed-${new Date().toISOString().slice(0,19).replace(/:/g,"-")}.csv`;

    // Try GM_download first without saveAs to avoid Save-as prompt.
    try {
      // Note: do NOT set saveAs: true — omitting or setting false avoids forcing a "Save As" dialog
      GM_download({ url: "data:text/csv;charset=utf-8," + encodeURIComponent(csv), name: filename, saveAs: false });
      console.info("[CRE Export v2.7] GM_download initiated (saveAs:false)", filename);
      return;
    } catch (e) {
      console.warn("[CRE Export v2.7] GM_download error, falling back to anchor blob", e);
    }

    // Fallback: create an anchor with blob and trigger click (works silently in most browsers unless browser forces ask)
    try {
      const blob = new Blob([csv], { type: "text/csv" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      // Insert hidden anchor, click, remove
      a.style.display = "none";
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 1500);
      console.info("[CRE Export v2.7] fallback download triggered", filename);
    } catch (e) {
      // Last resort: open data URL in new tab (user can save)
      const dataUrl = "data:text/csv;charset=utf-8," + encodeURIComponent(csv);
      window.open(dataUrl, "_blank");
      console.info("[CRE Export v2.7] opened CSV in new tab as last resort");
    }
  }

  // Modal UI (same as prior version)
  function createProgressModal() {
    const existing = document.getElementById("tm_cre_modal_v27");
    if (existing) return existing._controller;
    const overlay = document.createElement("div");
    overlay.id = "tm_cre_modal_v27";
    overlay.style.position = "fixed";
    overlay.style.left = "0";
    overlay.style.top = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.zIndex = 99999;
    overlay.style.background = "rgba(0,0,0,0.45)";
    overlay.style.display = "flex";
    overlay.style.alignItems = "center";
    overlay.style.justifyContent = "center";

    const panel = document.createElement("div");
    panel.style.width = "520px";
    panel.style.maxWidth = "92%";
    panel.style.background = "#fff";
    panel.style.borderRadius = "8px";
    panel.style.padding = "18px";
    panel.style.boxShadow = "0 8px 30px rgba(0,0,0,0.4)";
    panel.style.fontFamily = "Arial, sans-serif";
    panel.style.color = "#222";

    const title = document.createElement("div");
    title.innerText = "Exporting CSV — Progress";
    title.style.fontSize = "18px";
    title.style.fontWeight = "700";
    title.style.marginBottom = "8px";

    const desc = document.createElement("div");
    desc.innerText = "Fetching data from server. This may take a while for many pages. You can cancel at any time.";
    desc.style.fontSize = "13px";
    desc.style.marginBottom = "12px";
    desc.style.color = "#444";

    const barWrap = document.createElement("div");
    barWrap.style.width = "100%";
    barWrap.style.background = "#eee";
    barWrap.style.borderRadius = "6px";
    barWrap.style.overflow = "hidden";
    barWrap.style.height = "14px";
    barWrap.style.marginBottom = "12px";
    const bar = document.createElement("div");
    bar.style.width = "0%";
    bar.style.height = "100%";
    bar.style.background = "#4caf50";
    bar.style.transition = "width 300ms ease";
    barWrap.appendChild(bar);

    const stats = document.createElement("div");
    stats.style.fontSize = "13px";
    stats.style.display = "flex";
    stats.style.justifyContent = "space-between";
    stats.style.marginBottom = "12px";
    stats.innerHTML = `<span>Rows fetched: 0</span><span>Pages: 0</span>`;

    const details = document.createElement("div");
    details.style.fontSize = "12px";
    details.style.color = "#333";
    details.style.marginBottom = "12px";
    details.innerText = "Last page count: 0";

    const btnRow = document.createElement("div");
    btnRow.style.display = "flex";
    btnRow.style.justifyContent = "flex-end";
    btnRow.style.gap = "8px";

    const cancelBtn = document.createElement("button");
    cancelBtn.type = "button";
    cancelBtn.innerText = "Cancel";
    cancelBtn.style.background = "#f44336";
    cancelBtn.style.color = "#fff";
    cancelBtn.style.border = "none";
    cancelBtn.style.padding = "8px 12px";
    cancelBtn.style.borderRadius = "4px";
    cancelBtn.style.cursor = "pointer";

    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.innerText = "Close";
    closeBtn.style.background = "#e0e0e0";
    closeBtn.style.color = "#111";
    closeBtn.style.border = "none";
    closeBtn.style.padding = "8px 12px";
    closeBtn.style.borderRadius = "4px";
    closeBtn.style.cursor = "pointer";
    closeBtn.style.display = "none";

    btnRow.appendChild(closeBtn);
    btnRow.appendChild(cancelBtn);

    panel.appendChild(title);
    panel.appendChild(desc);
    panel.appendChild(barWrap);
    panel.appendChild(stats);
    panel.appendChild(details);
    panel.appendChild(btnRow);

    overlay.appendChild(panel);
    document.body.appendChild(overlay);

    let cancelled = false;
    function update({ rows = 0, pages = 0, lastCount = 0, percent = null, message = "" } = {}) {
      stats.innerHTML = `<span>Rows fetched: ${rows}</span><span>Pages: ${pages}</span>`;
      details.innerText = `Last page count: ${lastCount}${message ? " — " + message : ""}`;
      if (percent !== null) bar.style.width = `${Math.min(100, Math.max(0, percent))}%`;
      else bar.style.width = `${Math.min(100, Math.log10(1 + rows) * 12)}%`;
    }
    function setDone() { cancelBtn.style.display = "none"; closeBtn.style.display = "inline-block"; bar.style.width = "100%"; details.innerText = details.innerText + " — Complete"; }
    function setError(msg) { cancelBtn.style.display = "none"; closeBtn.style.display = "inline-block"; bar.style.background = "#f44336"; details.innerText = details.innerText + " — Error: " + msg; }
    function destroy() { overlay.remove(); }
    cancelBtn.addEventListener("click", () => { cancelled = true; details.innerText = details.innerText + " — Cancelling..."; });
    closeBtn.addEventListener("click", () => destroy());

    overlay._controller = { update, setDone, setError, destroy, isCancelled: () => cancelled };
    return overlay._controller;
  }

  async function fetchAllPagesWithModal(template, controller) {
    const all = [];
    let start = template.pagination && template.pagination.startIndex ? template.pagination.startIndex : 0;
    const size = (template.pagination && template.pagination.size) || PAGE_SIZE;
    let pagesFetched = 0;

    while (true) {
      if (controller.isCancelled()) break;
      template.pagination.startIndex = start;
      console.info(`[CRE Export v2.7] fetching startIndex=${start}`);

      const resp = await new Promise((res, rej) => {
        GM_xmlhttpRequest({
          method: "POST",
          url: location.origin + API_ENDPOINT,
          headers: { "Content-Type": "application/json", "Accept": "application/json, text/plain, */*" },
          data: JSON.stringify(template),
          onload: r => res(r),
          onerror: e => rej(e),
          ontimeout: e => rej(e)
        });
      });

      let json;
      try { json = JSON.parse(resp.responseText); }
      catch (e) {
        try {
          const txt = resp.responseText || "";
          const first = txt.indexOf("{");
          const last = txt.lastIndexOf("}");
          if (first !== -1 && last !== -1 && last > first) json = JSON.parse(txt.substring(first, last + 1));
          else json = {};
        } catch (e2) { throw new Error("Failed to parse server response as JSON"); }
      }

      const items = normalizeItemsArray(json);
      const count = items.length || 0;
      all.push(...items);
      pagesFetched++;
      controller.update({ rows: all.length, pages: pagesFetched, lastCount: count });

      if (controller.isCancelled()) break;
      if (count === 0) break;
      if (count < size) break;
      start += size;
      if (all.length > 500000) throw new Error("Too many rows - aborting");
    }
    return all;
  }

  function attachExportButton() {
    if (document.getElementById("tm_cre_export_v27")) return;
    const listBtn = Array.from(document.querySelectorAll("button, a")).find(el =>
      (el.innerText || "").trim().toUpperCase() === "LIST KEYWORDS"
    );
    const fallbackBtn = document.querySelector("button.btn-primary, button.btn.btn-default.btn-primary");
    const anchor = listBtn || fallbackBtn;
    if (!anchor) return;

    const btn = document.createElement("button");
    btn.id = "tm_cre_export_v27";
    btn.type = "button";
    btn.className = "btn btn-default";
    btn.style.marginLeft = "8px";
    btn.style.background = "#ffea3b"; // yellow
    btn.style.color = "#111";
    btn.style.border = "1px solid #c5b300";
    btn.style.fontWeight = "600";
    btn.style.padding = "6px 10px";
    btn.innerText = EXPORT_BTN_TEXT;

    anchor.parentNode.insertBefore(btn, anchor.nextSibling);

    btn.addEventListener("click", async () => {
      try {
        btn.disabled = true;
        btn.innerText = "Exporting...";
        console.info("[CRE Export v2.7] Start export");

        const { template, detected } = buildTemplateFromReactSelects();
        console.info("[CRE Export v2.7] Detected:", detected);

        if (!template.keywordSearchCriteria.processes.length || !template.keywordSearchCriteria.marketplaces.length) {
          console.warn("[CRE Export v2.7] Could not detect Ad Program / Marketplace. Falling back to SPONSORED_PRODUCTS + BE");
          template.keywordSearchCriteria.processes = ["SPONSORED_PRODUCTS"];
          template.keywordSearchCriteria.marketplaces = ["BE"];
        }

        const controller = createProgressModal();
        controller.update({ rows: 0, pages: 0, lastCount: 0, percent: 0, message: "Starting..." });

        let rows = [];
        try {
          rows = await fetchAllPagesWithModal(template, controller);
        } catch (err) {
          controller.setError(err.message || String(err));
          console.error("[CRE Export v2.7] fetch error:", err);
          throw err;
        }

        if (!rows || rows.length === 0) {
          controller.update({ rows: 0, pages: 0, lastCount: 0, message: "No rows found" });
          controller.setDone();
          btn.disabled = false;
          btn.innerText = EXPORT_BTN_TEXT;
          return;
        }

        controller.update({ rows: rows.length, pages: Math.ceil(rows.length / PAGE_SIZE), lastCount: rows.length % PAGE_SIZE || PAGE_SIZE, percent: 100, message: "Preparing CSV..." });

        const csvRows = rows.map(mapItemToCsvRow);
        try {
          triggerCsvDownload(csvRows);
          controller.setDone();
        } catch (e) {
          controller.setError(e.message || "Download failed");
          console.error("[CRE Export v2.7] download error", e);
        }
      } catch (err) {
        alert("Export failed: " + (err && err.message ? err.message : "unknown"));
      } finally {
        btn.disabled = false;
        btn.innerText = EXPORT_BTN_TEXT;
      }
    });
  }

  const observer = new MutationObserver(() => attachExportButton());
  observer.observe(document.documentElement || document.body, { childList: true, subtree: true });
  setTimeout(attachExportButton, 800);

  console.info("[CRE Export v2.7] ready - will attempt silent downloads (depends on browser settings)");
})();